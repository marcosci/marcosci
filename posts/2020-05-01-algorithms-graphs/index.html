<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Latitudinal Density Lines with R | Marco Sciaini</title>
  <meta name="description" content="Hi there, I&#39;m Marco. Nice to meet you! I am a Data Analyst and Geospatial Enthusiast. I build custom statistical models, data visualisations, maps and dashboards. Check out my toolbox, thoughts and projects below!">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Latitudinal Density Lines with R" />
<meta property="og:description" content="Undirected Graphs Some problems  Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once  classical NP-complete problem.  Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical?  No one knows so far. A lonstanding open problem   Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://marcosci.github.io/posts/2020-05-01-algorithms-graphs/" />
<meta property="article:published_time" content="2020-11-05T09:00:00+00:00" />
<meta property="article:modified_time" content="2020-11-05T09:00:00+00:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Latitudinal Density Lines with R"/>
<meta name="twitter:description" content="Undirected Graphs Some problems  Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once  classical NP-complete problem.  Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical?  No one knows so far. A lonstanding open problem   Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree)."/>

  
  
    
  
  
  <link rel="stylesheet" href="https://marcosci.github.io/css/style-light.css">
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://marcosci.github.io/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

  <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts">Writings</a></li>
         
        <li><a href="/tags">Tags</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li>
          <a class="icon" href=" https://marcosci.github.io/posts/2020-06-06-changes-in-java-string/">
            <i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i>
          </a>
        </li>
        
        
        <li>
          <a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
            <i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i>
          </a>
        </li>
        <li>
          <a class="icon" href="#">
            <i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i>
          </a>
        </li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f">
      <i class="fab fa-facebook " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&text=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-twitter " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-linkedin " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&is_video=false&description=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-pinterest " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Latitudinal%20Density%20Lines%20with%20R&body=Check out this article: https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f">
      <i class="fas fa-envelope " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-get-pocket " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-reddit " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-stumbleupon " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-digg " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&name=Latitudinal%20Density%20Lines%20with%20R&description=Undirected%20Graphs%20Some%20problems%20%20Path%20Shortest%20path%20Cycle%20Ehler%20tour%3a%20A%20cycle%20that%20uses%20each%20edge%20excatly%20once.%20Hamilton%20tour%3a%20A%20cycle%20that%20uses%20each%20vertex%20exactly%20once%20%20classical%20NP-complete%20problem.%20%20Connectivity%20MST%3a%20Biconnectivity%3a%20A%20vertex%20whose%20removal%20disconnects%20the%20graph%20Planarity%20Graph%20isomorphism%3a%20Are%20two%20graphs%20identical%3f%20%20No%20one%20knows%20so%20far.%20A%20lonstanding%20open%20problem%20%20%20Representations%20Real-world%20graphs%20tend%20to%20be%20sparse%20%28huge%20number%20of%20vertices%2c%20small%20average%20vertex%20degree%29.">
      <i class="fab fa-tumblr " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&t=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-hacker-news " aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>
    <div id="toc">
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#undirected-graphs">Undirected Graphs</a>
<ul>
<li><a href="#some-problems">Some problems</a></li>
<li><a href="#representations">Representations</a></li>
<li><a href="#adjacency-list-data-structure">Adjacency-list Data structure</a></li>
<li><a href="#depth-first-search-dfs">Depth-first Search (DFS)</a></li>
<li><a href="#breadth-first-search-bfs">Breadth-first Search (BFS)</a></li>
<li><a href="#applications-of-dfs">Applications of DFS</a>
<ul>
<li><a href="#connected-components">Connected components</a></li>
<li><a href="#cycle-detection">Cycle detection</a></li>
<li><a href="#two-colorability">Two-colorability</a></li>
<li><a href="#symbol-graphs">Symbol graphs</a></li>
<li><a href="#degrees-of-separation">Degrees of separation</a></li>
</ul></li>
</ul></li>
<li><a href="#directed-graphs">Directed Graphs</a>
<ul>
<li><a href="#representations-1">Representations</a></li>
<li><a href="#digraph-search">Digraph search</a></li>
<li><a href="#topological-sort">Topological Sort</a>
<ul>
<li><a href="#directed-cycle-detection">Directed cycle detection</a></li>
</ul></li>
<li><a href="#strong-components">Strong components</a>
<ul>
<li><a href="#kosaraju-sharir-algorithm">Kosaraju-Sharir Algorithm</a></li>
</ul></li>
</ul></li>
<li><a href="#minimum-spanning-trees">Minimum Spanning Trees</a>
<ul>
<li><a href="#edge-weight-graph-data-type">Edge-weight Graph Data Type</a></li>
<li><a href="#greedy-mst-algorithm"><strong>Greedy MST Algorithm:</strong></a></li>
<li><a href="#implementations-1-kruskal-s-algorithm">Implementations 1: Kruskal&rsquo;s algorithm</a></li>
<li><a href="#implementations-2-prim-s-algorithm">Implementations 2: Prim&rsquo;s algorithm</a></li>
</ul></li>
<li><a href="#shortest-paths">Shortest Paths</a>
<ul>
<li><a href="#edge-weighted-digraph-data-strcuture">Edge-weighted digraph data strcuture</a></li>
<li><a href="#generic-single-source-shortest-paths">Generic Single-source Shortest paths</a>
<ul>
<li><a href="#relax-edge-e-v-w">Relax edge e = v-&gt;w</a></li>
<li><a href="#optimality-conditions">Optimality conditions</a></li>
<li><a href="#generic-algorithm">Generic algorithm</a></li>
</ul></li>
<li><a href="#implement-1-dijkstra-s-algorithm">Implement 1: Dijkstra&rsquo;s algorithm</a></li>
<li><a href="#implement-2-topological-sort-algorithm">Implement 2: Topological sort algorithm</a></li>
<li><a href="#implement-3-bellman-ford-algorithm">Implement 3: Bellman-Ford algorithm</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
  </span>
</div>


  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 class="posttitle" itemprop="name headline">
        Latitudinal Density Lines with R
      </h1>
      <div class="meta">
        
        <div class="postdate">
          
          <time datetime="2020-11-05 09:00:00 &#43;0000 UTC" itemprop="datePublished">2020-11-05</time>
          
        </div>
        
        
        <div class="article-tag">
            <i class="fas fa-tag"></i>
            
            
            <a class="tag-link" href="/tags/algorithms" rel="tag">Algorithms</a>
            
             ,  
            <a class="tag-link" href="/tags/r" rel="tag">R</a>
            
             ,  
            <a class="tag-link" href="/tags/maps" rel="tag">Maps</a>
            
        </div>
        
      </div>
    </header>

  
    <div class="content" itemprop="articleBody">
      

<h2 id="undirected-graphs">Undirected Graphs</h2>

<h3 id="some-problems">Some problems</h3>

<ul>
<li>Path</li>
<li>Shortest path</li>
<li>Cycle</li>
<li>Ehler tour: A cycle that uses each edge excatly once.</li>
<li>Hamilton tour: A cycle that uses each vertex exactly once

<ul>
<li>classical NP-complete problem.</li>
</ul></li>
<li>Connectivity</li>
<li>MST:</li>
<li>Biconnectivity: A vertex whose removal disconnects the graph</li>
<li>Planarity</li>
<li>Graph isomorphism: Are two graphs identical?

<ul>
<li>No one knows so far. A lonstanding open problem</li>
</ul></li>
</ul>

<h3 id="representations">Representations</h3>

<p>Real-world graphs tend to be <strong>sparse</strong> (huge number of vertices, small average vertex degree).</p>

<ul>
<li>Set-of-edges representation

<ul>
<li>unefficient</li>
</ul></li>
<li>Adjacency-matrix representation

<ul>
<li>space cost is prohibitive</li>
</ul></li>
<li>Adjacency-list array representation

<ul>
<li>GOOD</li>
</ul></li>
</ul>

<h3 id="adjacency-list-data-structure">Adjacency-list Data structure</h3>

<ul>
<li>Space usage proportional to V + E</li>
<li>Constant time to add an edge</li>
<li>Time proportional to the degree of v to iterate through vertices adjacent to v</li>
</ul>

<h3 id="depth-first-search-dfs">Depth-first Search (DFS)</h3>

<p>Typical applications:
* Find all vertices connected to a given source vertex
* Find a path between two vertices</p>

<p>Algorithm:
* Use recursion (a function-call stack) or an explicit stack.
* Mark each visited vertex (and keep track of edge taken to visit it)
* Return (retrace steps) when no unvisited options</p>

<pre><code class="language-Java">public class DepthFirstPaths{
    private blloean[] marked;
    private int[] edgeTO;
    private int s;
    public DepthFirstPaths(Graph G, int s)
    {
        // ...
        dfs(G, s);
    }

    private void dfs(Graph Gm int v)
    {
        marked[v] = true;
        for (int w : G.adj(v))
            if (!marked[v])
            {
                dfs(G, w)
                edgeTo[w] = v;
            }
    }
}
</code></pre>

<p>Propositions:
1. DFS marks all vertices connected to s in time proportional to the sum of their degrees.
2. After DFS, can find vertices connected to s in constant time and can find a path to s in time proportional to its length.</p>

<h3 id="breadth-first-search-bfs">Breadth-first Search (BFS)</h3>

<p>Typical applications:
* shortest path</p>

<p>Algorithm:
* Put s onto a queue, and mark s as visited
* Take the next vertex v from the queue and mark it
* Put onto the queue all unmarked vertices that are adjacent to v</p>

<pre><code class="language-Java">public class BreadthFirstPaths
{
    private boolean[] marked;
    private int[] edgeTo;
    // ...
    private void bfs(Graph G, int s)
    {
        Queue&lt;Integer&gt; q = new Queue&lt;&gt;();
        q.enqueue(s);
        marked[s] = ture;
        while (!q.isEmpty())
        {
            int v = q.dequeue();
            for (int w: G.adj(v))
            {
                if (!marked[w])
                {
                    q.enqueue(w);
                    marked[w] = true;
                    edgeTo[w] = v;
                }
            }
        }
    }
}
</code></pre>

<p>Proposition:
1. BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V</p>

<h3 id="applications-of-dfs">Applications of DFS</h3>

<h4 id="connected-components">Connected components</h4>

<p>The goal is to preprocess graph to answer queries of the form <em>is v connected to w?</em> in constant time.</p>

<p>The relation <em>is connected to</em> is an equivalence relation:
* Reflexive: v is connected to v
* Symmetric: if v is connected to w, then w is connected to v
* Transitive: if v connected to w and w connected to x, then v connected to x</p>

<pre><code class="language-Java">public class CC {
    private boolean[] marked;
    private int[] id;
    private int count;

    public CC(Graph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v = 0, v &lt; G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    // ...

    private void dfs(Graph G, int v) {
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w)
            }
        }
    }
}
</code></pre>

<h4 id="cycle-detection">Cycle detection</h4>

<p>Problem: Is a given graph acylic?</p>

<p><strong>TODO</strong></p>

<h4 id="two-colorability">Two-colorability</h4>

<p>Problem: Is the graph bipartite?</p>

<p><strong>TODO</strong></p>

<h4 id="symbol-graphs">Symbol graphs</h4>

<p><strong>TODO</strong></p>

<h4 id="degrees-of-separation">Degrees of separation</h4>

<p><strong>TODO</strong></p>

<h2 id="directed-graphs">Directed Graphs</h2>

<blockquote>
<p>A directed graph (or digraph) is a set of vertices and a collection of directed edges. Each directed edge connects an ordered pair of vertices.</p>
</blockquote>

<ul>
<li><em>outdegree</em>: the number of edges going <strong>from</strong> it</li>
<li><em>indegree</em>: the number fo edges going <strong>into</strong> it</li>
<li><em>directed path</em>: a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence</li>
<li><em>directed cycle</em></li>
<li><em>simple cycle</em>: a cycle with no repeated edges or vertices</li>
</ul>

<h3 id="representations-1">Representations</h3>

<p>Again, use <a href="#Adjacency-list-Data-structure">adjacency-lists representation</a>
* Based on iterating over vertices pointing from v
* Real-world digraphs tend to be sparse</p>

<pre><code class="language-Java">public class Digraph {
    private final int V;
    private final Bag&lt;Integer&gt;[] adj;

    public Digraph(int V) {
        this.V = V;
        adj = (Bag&lt;Integer&gt;[]) new Bag[V];
        for (int v = 0; v &lt; V; v++) {
            adj[v] = new Bag&lt;Integer&gt;[];
        }
    }

    public void addEdge(int v, int w) {
        adj[v].add(w);
    }

    public Iterable&lt;Integer&gt; adj(int v) {
        return adj[v];
    }
}
</code></pre>

<h3 id="digraph-search">Digraph search</h3>

<p>Reachabiliity problem: Find all vertices reachable from s along a directed path.</p>

<p>We can use <a href="#Depth-first-Search-(DFS)">the same dfs method as for undirected graphs</a>.
* Every undirected graph is a digraph with edges in both directions.
* DFS is a digraph algorithm,</p>

<p>Reachability applications:
* program control-flow analysis
    - Dead-code elimination
    - infinite-loop detection
* mark-sweep garbage collector</p>

<p>Other DFS problems:
* Path findind
* Topological sort
* Directed cycle detection
* &hellip;</p>

<p>BFS problems:
* shortest path
* multiple-source shortest paths
* web crawler application</p>

<h3 id="topological-sort">Topological Sort</h3>

<blockquote>
<p>Topological sort: Given a digraph, put the vertices in order such that all its directed edges point from a vertix earlier in the order to a vertex later in the order (or report impossible).</p>
</blockquote>

<p>A digraph has a topological order <strong>if and only if</strong> it is a <em>directed acyclic graph</em> (DAG).
Topological sort redraws DAG so all edges poitn upwards.</p>

<p>use <strong>DFS</strong> again. It can be proved that reverse postorder of a DAG is a topological order.
(check P578 for the definition of Preorder/Postorder)</p>

<pre><code class="language-Java">public class DepthFirstOrder {
    private boolean[] marked;
    private Stack&lt;Integer&gt; reversePost;

    publiv DepthFirstOrder(Digraph G) {
        reversePost = new Stack&lt;Integer&gt;();
        marked = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++) {
            if (!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digrapg G, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w)
        }
        reversePost.push(v);
    }
}
</code></pre>

<h4 id="directed-cycle-detection">Directed cycle detection</h4>

<p>To find out if a given digraph is a DAG, we can try to find a directec cycle in the digraph.
Use DFS and a stack to track the cycle.</p>

<pre><code class="language-Java">// TODO
</code></pre>

<p>Some very typical applications of directed cycle detection and topological sort:
(A directed cycle means the problem is infeasible)
* job schedule
* course scuedule
* inheritance
* spreadsheet
    - vertex: cell
    - edge: formula
* symbolic links</p>

<h3 id="strong-components">Strong components</h3>

<p>Vertices v and w are <strong>strongly connected</strong> if there is both a directed path from v to w and a directed path from w to v.
Strong connectivity is an equvicalence relation.</p>

<h4 id="kosaraju-sharir-algorithm">Kosaraju-Sharir Algorithm</h4>

<p>Kosaraju-Sharir is easy to implement but difficutl to understand. It runs DFS twice:
* Given a digraph G, run DFS to compute the topological order of its reverse $G^R$
* Run DFS on G in the order given by first DFS</p>

<p>TODO: ADD Proof</p>

<p><a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html</a></p>

<pre><code class="language-Java">public class KosarajuSharirSCC {
    private boolean[] marked;     // marked[v] = has vertex v been visited?
    private int[] id;             // id[v] = id of strong component containing v
    private int count;            // number of strongly-connected components

    /**
     * Computes the strong components of the digraph {@code G}.
     * @param G the digraph
     */
    public KosarajuSharirSCC(Digraph G) {

        // compute reverse postorder of reverse graph
        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

        // run DFS on G, using reverse postorder to guide calculation
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v : dfs.reversePost()) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }
    }

    // DFS on graph G
    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    // ...
}
</code></pre>

<h2 id="minimum-spanning-trees">Minimum Spanning Trees</h2>

<p>An edge-weighted-graph is a graph where we associate weight or costs with each edge.
A spanning tree of an undirected edge-weighted graph G is a subgraph T that is both <strong>a tree (conneted and acyclic)</strong> and <strong>spanning (includes all of the vertices)</strong>.
Given an (connected) undirected edge-weighted graph G with V vertices and E edges, the MST of it must have <strong>V - 1</strong> edges.
If the graph is not connceted, we compute minimum spanning forest (MST of each component).</p>

<ul>
<li>A <em>cut</em> in a graph is a partition of its vertices into two (nonempty) sets</li>
<li>A <em>crossing edge</em> connects a vertex in one set with a vertex in the other.</li>
<li>Cut property: Given any cut, the crossing edge of min weight is in the MST.</li>
</ul>

<h3 id="edge-weight-graph-data-type">Edge-weight Graph Data Type</h3>

<p>Edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html</a></p>

<p>EdgeWeigthedGraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html</a></p>

<h3 id="greedy-mst-algorithm"><strong>Greedy MST Algorithm:</strong></h3>

<ul>
<li>Start with all edges colored gray.</li>
<li>Find cut with no blacked crossing edges; color its min-weight edge black.</li>
<li>Repeat until V-1 edges are colored black.</li>
</ul>

<h3 id="implementations-1-kruskal-s-algorithm">Implementations 1: Kruskal&rsquo;s algorithm</h3>

<p>For edges in ascending order of weight:
* Add next edge to Tree unless doing so would create a cycle.</p>

<p>To efficiently solve this problem, use union-find :
1. use a priority queue to maintain all the edges in V
2. union-find data structure:
    - maintain a set for each connected component in T.
    - if v and w are in saome set, then adding v-&gt;w would create a cycle
    - to add v&gt;w to T, merge sets containing v and w.</p>

<p>TODO: Add code</p>

<h3 id="implementations-2-prim-s-algorithm">Implementations 2: Prim&rsquo;s algorithm</h3>

<ul>
<li>Start with vertex 0 and greedily grow tree T.</li>
<li>Add To T the min weight edge with exactly oue endpoint in T.</li>
<li>Reapeat unitl V - 1 edges.</li>
</ul>

<p>The key to solve this problem is how do we find the crossing edge of minimal weight efficiently.</p>

<p>A lazy solution (in time proportional to $ElogE$, fair enough):
1. Maintain a PQ of edges with (at least) one endpoint in T
    - Key = edge, priority = weight
2. Delete-min to determine next edge e = v-&gt;w to add to T
3. Disregard if both endpoints v and w are marked (both in T)
4. Otherwise, let w be the unmarked vertex (not in T)
    - add to PQ and edge incident to w (assuming other endpoint not in T)
    - add e to T and mark w</p>

<p>TODO: add code</p>

<p>A eager solution (in time proprotional to $ElogV$, better):
1. Maintain a PQ of vertices connected by an edge to T, where priority of v = weight of shortedt edge connecting v to T
2. Delete min vertex v and add its associated edge e = v-&gt;w to T
3. Update PQ by considering all edges e = v-&gt;x incident to v
    - ignore if x is already in T
    - add x to PQ if not alread on it
    - decrease priority of x if v-&gt;x becomes shortest edge connecting x to T</p>

<p>This solution uses an <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html">indexed priority queue</a> data structure.</p>

<p>TODO: add code</p>

<h2 id="shortest-paths">Shortest Paths</h2>

<p><strong>Some variants:</strong>
* Which vertices?
    - Single source
    - Source-sink
    - All pairs
* Edge weights
    - Nonegative weights
    - Euclidean weights
    - Arbitrary weights
* Cycles?
    - No directed cycles
    - No negative cycles</p>

<h3 id="edge-weighted-digraph-data-strcuture">Edge-weighted digraph data strcuture</h3>

<p>Weighted directed edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html</a></p>

<p>Edge-weighted digraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html</a></p>

<p>Use adjacency-lists implementation same as <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">EdgeWeightedGraph</a></p>

<h3 id="generic-single-source-shortest-paths">Generic Single-source Shortest paths</h3>

<p>Our goal is to find the shortest path from s to every other vertex. As a result, what we find will be the <strong>shortest-paths tree (SPT)</strong> for source s.</p>

<h4 id="relax-edge-e-v-w">Relax edge e = v-&gt;w</h4>

<ul>
<li>distTo[v] is length of shortest known path from s to v</li>
<li>distTo[w] is length of shortest known path from s to w</li>
<li>esgeTo[w] is last edge on shortest known pathh from s to w</li>

<li><p>if e = v-&gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w]</p>

<pre><code class="language-Java">private void relax(DirectedEdge e) {
int v = e.from(), w = e.to();
if (distTo[w] &gt; distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
}
}
</code></pre></li>
</ul>

<h4 id="optimality-conditions">Optimality conditions</h4>

<p>Given an edge-weighted digraph G, distTo[] are the shortest path distances from s <strong>iff</strong>:
* distTo[s] = 0
* For each vertex v, distTo[v] is the length of some path from s to v.
* For each edge e = v-&gt;w, distTo[w] &lt;= distTo[v] + e.weight()</p>

<h4 id="generic-algorithm">Generic algorithm</h4>

<pre><code>Generic algorithm (to compute SPT from s) {
    Initialize distTo[s] = 0 and distTo[v] = $\infty$

    Repeat until optimality conditions are satisfied:
        - Relax any edge
}
</code></pre>

<p>Efficient implementations:
* Nonnegative weights: <a href="#implement-1-dijkstras-algorithm">Dijkstra&rsquo;s algorithm</a>
* No directed cycles (DAGs): <a href="#implement-2-topological-sort-algorithm">Topological sort algorithm</a>
* No negative cycles: <a href="#implement-3-bellman-ford-algorithm">Bellman-Ford</a></p>

<h3 id="implement-1-dijkstra-s-algorithm">Implement 1: Dijkstra&rsquo;s algorithm</h3>

<p>When there is no nonnegative weight exists, we can use Dijkstra&rsquo;s algorithm.
* Consider vertices in increasing order of distance from s (non-tree vertex with the lowest distTo[] value)
* add vertex to tree and relax all edges pointing from that vertex</p>

<pre><code class="language-Java">public class DijkstraSP{
        // ...
    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        edgeTo = new DirectedEdge[G.V()];
        distTo = new double[G.V()];
        pq = new IndexMinPQ&lt;Double&gt;(G.V());

        for (int v = 0; v &lt; G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0;

        pq.insert(s, 0.0);
        while(!pq.isEmpty()) {
            int v= pq.delMin();
            for (DirectedEdge e : G.adj(v)) {
                relax(e);
            }
        }
    }

    private void relax(DirectedEdge e) {
        int v = e.from(), w = e.to();
        if (distTo[w] &gt; distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else pq.insert(w, distTo[w]);
        }
    }
}
</code></pre>

<p><strong>Compare to Prim&rsquo;s algorithm:</strong>
* Both are computing a graph&rsquo;s spanning tree
* Prim&rsquo;s algorithm choose closest vertex to tree as next vertex, while Dijkstra&rsquo;s algorithm choose closest vertex to the source</p>

<h3 id="implement-2-topological-sort-algorithm">Implement 2: Topological sort algorithm</h3>

<p>When the graph is a DAG, we can consider vertices in topological order and do relaxing.</p>

<pre><code class="language-Java">    // ...
    Topological topological = new Topological(G);
    for (int v : topological.order()) {
        for (DirectedEdge e : G.adj(v)) {
            relax(e);
        }
    }
</code></pre>

<p><strong><a href="https://en.wikipedia.org/wiki/Seam_carving">Seam carving</a></strong>: Resize an image without distortion.</p>

<p><strong>Longest paths</strong>:
* Formuate as a shortest paths problem in edge-weighted DAGs
    - Negate all weights
    - Find shortest paths
    - Negate weights in result
* Allpication: Parallel job scheduling (<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%83%86%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%91%E3%82%B9%E6%B3%95">Critical path method, CPM</a>).</p>

<h3 id="implement-3-bellman-ford-algorithm">Implement 3: Bellman-Ford algorithm</h3>

<blockquote>
<p>A SPT exists iff no negative cycles (a directed cycle whose sum of edge weights is negative).</p>
</blockquote>

<p>When we want to find shortest paths with nagative weights, Dijkstra&rsquo;s algorithms doesn&rsquo;t work.
We can use Bellman-Ford algorithm as long as there is no negative cycle in the graph.
(Bellman-Ford algorithm is a dynamic programming algorithm)</p>

<ul>
<li>Initialize distTo[s] = 0 and distTo[v] = $\infty$</li>

<li><p>Maintain a queue and repeat until the queue is empty or find a cycle:</p>

<ul>
<li>Pop vertex v from q</li>

<li><p>Relax each edge pointing from v to  any vertex w:</p>

<ul>
<li><p>if distTo[w] can be de decreased, update distTo[w] and add w to the queue</p>

<pre><code class="language-Java">// ...
public BellmanFordSP(EdgeWeightedDigraph G, int s) {
distTo  = new double[G.V()];
edgeTo  = new DirectedEdge[G.V()];
onQueue = new boolean[G.V()];
for (int v = 0; v &lt; G.V(); v++)
distTo[v] = Double.POSITIVE_INFINITY;
distTo[s] = 0.0;

// Bellman-Ford algorithm
queue = new Queue&lt;Integer&gt;();
queue.enqueue(s);
onQueue[s] = true;
while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) {
int v = queue.dequeue();
onQueue[v] = false;
relax(G, v);
}
}

private void relax(EdgeWeightedDigraph G, int v) {
for (DirectedEdge e : G.adj(v)) {
int w = e.to();
if (distTo[w] &gt; distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
    if (!onQueue[w]) {
        queue.enqueue(w);
        onQueue[w] = true;
    }
}
if (++cost % G.V() == 0) {
    findNegativeCycle();
    if (hasNegativeCycle()) return;  // found a negative cycle
}
}
}

</code></pre></li>
</ul></li>
</ul></li>
</ul>

<p>Bellman-Ford algorithm can also be used for finding a negative cycle.</p>

<p>Negative cycle application: arbitrage detection.</p>

    </div>
  </article>

  
  





  <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/posts">Writings</a></li>
         
          <li><a href="/tags">Tags</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#undirected-graphs">Undirected Graphs</a>
<ul>
<li><a href="#some-problems">Some problems</a></li>
<li><a href="#representations">Representations</a></li>
<li><a href="#adjacency-list-data-structure">Adjacency-list Data structure</a></li>
<li><a href="#depth-first-search-dfs">Depth-first Search (DFS)</a></li>
<li><a href="#breadth-first-search-bfs">Breadth-first Search (BFS)</a></li>
<li><a href="#applications-of-dfs">Applications of DFS</a>
<ul>
<li><a href="#connected-components">Connected components</a></li>
<li><a href="#cycle-detection">Cycle detection</a></li>
<li><a href="#two-colorability">Two-colorability</a></li>
<li><a href="#symbol-graphs">Symbol graphs</a></li>
<li><a href="#degrees-of-separation">Degrees of separation</a></li>
</ul></li>
</ul></li>
<li><a href="#directed-graphs">Directed Graphs</a>
<ul>
<li><a href="#representations-1">Representations</a></li>
<li><a href="#digraph-search">Digraph search</a></li>
<li><a href="#topological-sort">Topological Sort</a>
<ul>
<li><a href="#directed-cycle-detection">Directed cycle detection</a></li>
</ul></li>
<li><a href="#strong-components">Strong components</a>
<ul>
<li><a href="#kosaraju-sharir-algorithm">Kosaraju-Sharir Algorithm</a></li>
</ul></li>
</ul></li>
<li><a href="#minimum-spanning-trees">Minimum Spanning Trees</a>
<ul>
<li><a href="#edge-weight-graph-data-type">Edge-weight Graph Data Type</a></li>
<li><a href="#greedy-mst-algorithm"><strong>Greedy MST Algorithm:</strong></a></li>
<li><a href="#implementations-1-kruskal-s-algorithm">Implementations 1: Kruskal&rsquo;s algorithm</a></li>
<li><a href="#implementations-2-prim-s-algorithm">Implementations 2: Prim&rsquo;s algorithm</a></li>
</ul></li>
<li><a href="#shortest-paths">Shortest Paths</a>
<ul>
<li><a href="#edge-weighted-digraph-data-strcuture">Edge-weighted digraph data strcuture</a></li>
<li><a href="#generic-single-source-shortest-paths">Generic Single-source Shortest paths</a>
<ul>
<li><a href="#relax-edge-e-v-w">Relax edge e = v-&gt;w</a></li>
<li><a href="#optimality-conditions">Optimality conditions</a></li>
<li><a href="#generic-algorithm">Generic algorithm</a></li>
</ul></li>
<li><a href="#implement-1-dijkstra-s-algorithm">Implement 1: Dijkstra&rsquo;s algorithm</a></li>
<li><a href="#implement-2-topological-sort-algorithm">Implement 2: Topological sort algorithm</a></li>
<li><a href="#implement-3-bellman-ford-algorithm">Implement 3: Bellman-Ford algorithm</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>

    <div id="share-footer" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f">
      <i class="fab fa-facebook fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&text=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-twitter fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-linkedin fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&is_video=false&description=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-pinterest fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Latitudinal%20Density%20Lines%20with%20R&body=Check out this article: https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f">
      <i class="fas fa-envelope fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-reddit fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&title=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-digg fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&name=Latitudinal%20Density%20Lines%20with%20R&description=Undirected%20Graphs%20Some%20problems%20%20Path%20Shortest%20path%20Cycle%20Ehler%20tour%3a%20A%20cycle%20that%20uses%20each%20edge%20excatly%20once.%20Hamilton%20tour%3a%20A%20cycle%20that%20uses%20each%20vertex%20exactly%20once%20%20classical%20NP-complete%20problem.%20%20Connectivity%20MST%3a%20Biconnectivity%3a%20A%20vertex%20whose%20removal%20disconnects%20the%20graph%20Planarity%20Graph%20isomorphism%3a%20Are%20two%20graphs%20identical%3f%20%20No%20one%20knows%20so%20far.%20A%20lonstanding%20open%20problem%20%20%20Representations%20Real-world%20graphs%20tend%20to%20be%20sparse%20%28huge%20number%20of%20vertices%2c%20small%20average%20vertex%20degree%29.">
      <i class="fab fa-tumblr fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fmarcosci.github.io%2fposts%2f2020-05-01-algorithms-graphs%2f&t=Latitudinal%20Density%20Lines%20with%20R">
      <i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>

    <div id="actions-footer">
      
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;">
          <i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;">
          <i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;">
          <i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
          <i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>


  <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2020  Marco Sciaini 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts">Writings</a></li>
         
        <li><a href="/tags">Tags</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>


  


<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</html>
